#### 1. 面向对象介绍

OOP是使用独立的对象（包含数据和代码）作为应用程序模块的范例。

虽然OOP不能使得代码容易编写，但是它能够使得代码易于维护。将数据和代码结合在一起，能够使定位和修复错误的工作简单化，并最大限度地减少对其他对象的影响，提高代码的性能

- 封装：把相关的数据和代码结合在一起，并隐藏了实现细节。封装的好处是有利于程序的模块化，并把代码和其他代码分开

- 继承：是指一个新的对象能够从父对象中获取属性和方法，这种概念能用来建立VCL这样的多层次的对象，首先建立通用对象，然后创建这些通用对象的有专用功能的子对象

- 多态性：从字面上看，是指多种形状。调用一个对象变量的方法时，实际被调用的代码与实际在变量中的对象的实例有关

#### 2. Delphi不支持多继承

Delphi不想C++那样支持多继承，多继承是指一个对象能够继承两个不同的对象，并包含有两个父类对象的所有数据和代码

Delphi提供了两种方法来解决这个问题

- 在一个父类中包含其他的类，你能从Delphi的VCL中看到这种解决方法。
- 使用接口

#### 3. Delphi面向对象相关的三个术语

- 域（field），也被称为域定义或者实例变量，域是包含在对象中的数据变量。在对象中的一个域就像是在Delphi记录一个域，在C++中它被称为数据成员
- 方法（method），属于一个对象的过程和函数名，在C++中它被称为成员函数
- 属性（property），属性是外部代码访问对象中的数据和代码的访问器，属性隐藏了一个对象的具体实现的细节

> 最好不要直接访问对象的域，因为实现对象的细节可能改变。相反用访问器属性来访问对象，它不受对象细节的影响


#### 4. 基于对象和面向对象的编程

在某些工具中，你能操作对象但是不能创建对象，Visual Basic中的ActiveX控件（以前成为OCX）就是例子。虽然在程序中你能用ActiveX控件，但是你不能创建它，也不能派生它。这样的环境就被称为基于对象的环境

Delphi是完全的面向对象的环境，这表示在Delphi中你能用已经存在的组件创建新的对象，这些对象是可视的或者不可视的，甚至可以是设计时的窗体

#### 5. 声明和实例化

在使用一个对象之前，用class关键字声明一个对象。可以在一个程序或单元的type部分声明一个对象类型：

```pascal
type
    TFooObject = class;
```

除了声明一个对象类型，通常还需要一个对象的变量，即实例。实例定义在var部分

```pascal
var
    FooObject:TFooObject;
```

在Delphi中通过调用它的一个构造器来建立一个对象的实例，构造器主要是用来为对象创建实例并为对象中的域分配内存进行初始化使得对象处于可使用的状态。

Delphi的对象至少有一个构造器称为create()，但是一个对象可以有多个构造器。根据不同的对象类型，Create()可以有不同的参数。

调用构造器的语法如下

```pascal
FooObject:= TFooObject.Create;
```

注意这里调用构造器的语法有一点特殊，是通过类型来引用一个对象的Create()方法，而不是像其他方法那样通过实例来引用。

变量FooObject在调用时还没有被定义，而TFooObject已经静态地存在于内存之中，静态调用它的Create()方法是合法的。

通过调用构造器来创建对象的实例，这就是所谓的实例化

当一个对象实例用构造器创建的时候，编译器将对对象的每一个域经行初始化，你可以放心地认为所有数字被赋值为0，所有指针赋值为NIL，所有字符串为空


#### 6. 析构

当用完对象，应该调用这个实例的Free()方法来释放它。Free()首选进行检查保证这个对象实例不为NIL，然后调用对象的析构方法Destroy()。

析构进行与构造相反的工作，它释放所有分配的空间，并执行一些其他操作以保证对象能够适当地移除内存。

```pascal
FooObject.free;
```
不像调用Create()，这里是调用对象实例的Free()方法，记住不要直接调用Destroy()，而调用更安全的Free()方法，因为Free()首选进行检查保证这个对象实例不为NIL，然后调用对象的析构方法Destroy()。


在C++中，一个静态声明的对象在离开它的作用域时自动调用它的析构方法，但是要对动态生成的对象手动调用析构方法。这个规则在Delphi里面也适用，所有使用Create()动态声明创建的对象即使离开创建它时候的作用域，它也不会被自动释放，必须使用Free()方法来动态的析构，除了在Delphi中的隐式动态创建的对象，所以一定要记住这个规则：凡是创建的，都需要释放。这个规则有两个重要的特例

- 当对象被其他对象拥有时，它将替你释放对象。
- 引用技术的对象，当最后一个引用释放时，它将被析构。











